<!DOCTYPE html>
<html lang="en">

<head>
	<title>The virtual soundscape - Phenomena</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<link rel="shortcut icon" href="https://p3-blog.corruptedpixl.com/assets/favicons/favicon.svg">
</head>

<body>

	<!-- keep filesize low to avoid them from being slow -->
	<audio id="atmos" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/atmos.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/atmos.wav" type="audio/wav">
	</audio>
	<audio id="bass" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/bass.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/bass.wav" type="audio/wav">
	</audio>
	<audio id="drums" preload="auto" style="display: none">
		<source src="sounds/wdyf/drums.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/drums.wav" type="audio/wav">
	</audio>
	<audio id="guitars" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/guitars.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/guitars.wav" type="audio/wav">
	</audio>
	<audio id="lq" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/lq.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/lq.wav" type="audio/wav">
	</audio>
	<audio id="pads" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/pads.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/pads.wav" type="audio/wav">
	</audio>
	<audio id="plucks" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/plucks.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/plucks.wav" type="audio/wav">
	</audio>
	<audio id="tags" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/tags.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/tags.wav" type="audio/wav">
	</audio>
	<audio id="vocals" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/vocals.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/vocals.wav" type="audio/wav">
	</audio>

	<video id="video" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP1-drums.mp4" type="video/mp4" crossorigin="*">
		<!-- <source src="https://cdn.cpixl.com/other/tv-test.mp4" type="video/mp4" crossorigin="*"> -->
		<!-- <source src="https://cdn.cpixl.com/other/projectie_3.mp4" type="video/mp4" crossorigin="*"> -->
	</video>
	<video id="video2" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP2-synths.mp4" type="video/mp4" crossorigin="*">
		<!-- <source src="https://cdn.cpixl.com/other/futuresonus-parva-kickstarter.mp4" type="video/mp4" crossorigin="*"> -->
	</video>
	<video id="video3" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP3-guitars.mp4" type="video/mp4" crossorigin="*">
		<!-- <source src="https://cdn.cpixl.com/other/google-doodle.mp4" type="video/mp4" crossorigin="*"> -->
	</video>

	<div id="overlay">
		<button id="startButton">Play</button>
	</div>

	<script type="module">

		import { Text } from 'https://cdn.skypack.dev/troika-three-text';

		import * as THREE from 'https://cdn.skypack.dev/three';
		import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/lil-gui.module.min.js';
		import { FirstPersonControls } from 'https://cdn.skypack.dev/three/examples//jsm/controls/FirstPersonControls.js';
		import { VRButton } from 'https://cdn.skypack.dev/three/examples//jsm/webxr/VRButton.js';
		import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three/examples//jsm/webxr/XRControllerModelFactory.js';
		import { GLTFLoader } from 'https://cdn.skypack.dev/three/examples//jsm/loaders/GLTFLoader.js';

		const lyrics = await fetch('../../../lyrics/forest-spirit-sound.json').then(response => response.json());
		// const lyrics = await fetch('../../../lyrics/temporary-nothing.json').then(response => response.json());

		let camera, controls, scene, raycaster, renderer, light;
		let controller, controllerGrip;
		const tempMatrix = new THREE.Matrix4();
		const text = new Text();


		let mats = [];
		let meshes = [];
		let sounds = [];
		let analysers = [];

		let controllers = [];
		let controllerGrips = [];

		// groups
		let stemsGroup = new THREE.Group();
		let vidGroup = new THREE.Group();

		const clock = new THREE.Clock();

		const startButton = document.getElementById('startButton');
		startButton.addEventListener('click', init);

		const refDist = 50; // distance from where to start applying volume reduction 
		const objConfig = [
			{ name: 'atmos', color: 0xDDD3C3, sound: 'atmos', },
			{ name: 'bass', color: 0x812ADE, sound: 'bass', },
			{ name: 'drums', color: 0x3444E3, sound: 'drums', },
			{ name: 'guitars', color: 0xC714D6, sound: 'guitars', },
			{ name: 'lq', color: 0xE4406E, sound: 'lq', },
			{ name: 'pads', color: 0xFFA211, sound: 'pads', },
			{ name: 'plucks', color: 0xFFDE4A, sound: 'plucks', },
			{ name: 'tags', color: 0x02D37A, sound: 'tags', },
			{ name: 'vocals', color: 0x51C5C5, sound: 'vocals', },]

		function init() {

			const overlay = document.getElementById('overlay');
			overlay.remove();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, .1, 10000);
			// camera.position.set(0, 30, 200);
			camera.position.set(0, 30, 0);

			const listener = new THREE.AudioListener();
			camera.add(listener);

			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2(0x000000, 0.0025);


			const light = new THREE.DirectionalLight(0xffffff);
			light.position.set(1, 1, 1).normalize();
			scene.add(light);


			const sphere = new THREE.SphereGeometry(20, 32, 16);


			// VIDEOooo

			const video = document.querySelector('#video');
			const video2 = document.querySelector('#video2');
			const video3 = document.querySelector('#video3');



			const vidTextures = [
				new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video), side: THREE.DoubleSide }),
				new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2), side: THREE.DoubleSide }),
				new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3), side: THREE.DoubleSide }),
			];

			// const vidTex = new THREE.VideoTexture(video);
			// // vidTex.needsUpdate;
			// vidTex.minFilter = THREE.LinearFilter;
			// vidTex.magFilter = THREE.LinearFilter;
			// vidTex.format = THREE.RGBFormat;
			// // vidTex.wrapS = THREE.CubeReflectionMapping;
			// // vidTex.wrapT = THREE.CubeReflectionMapping;
			// vidTex.repeat.set(100, 100);
			// // video.crossOrigin = 'anonymous';

			const triangleSize = .5;
			const triangle = new THREE.Shape(); // create a triangle
			triangle.moveTo(10 * triangleSize, 0); // right point
			triangle.lineTo(-9.4 * triangleSize, 0); // left point
			triangle.lineTo(0.16, 16.8 * triangleSize); // top point
			triangle.lineTo(10 * triangleSize, 0); // back to start to close the shape

			const vidShapeSideOne = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			const vidShapeSideTwo = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			vidShapeSideOne.position.set(10, 10.08, -14.85);
			vidShapeSideTwo.position.set(-10, 10.08, -14.85);
			vidShapeSideOne.rotateY(Math.PI / 2); // 180° radians
			vidShapeSideTwo.rotateY(Math.PI / 2); // 180° radians
			// scene.add(vidShapeSideOne);
			// scene.add(vidShapeSideTwo);

			// let vidMesh = new THREE.Mesh(
			// 	// new THREE.PlaneGeometry(20, 10),
			// 	new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: 30, }), // extrude triangle
			// 	// new THREE.MeshBasicMaterial({ map: vidTex }));
			// 	// extrudedTriangle,
			// 	[
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffbb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00bb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x0000ff }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffffff }),
			// 	]);
			// // new THREE.MeshFaceMaterial(vidTextures));
			// // new THREE.MeshBasicMaterial({ color: 0xffbb00 }));

			// vidMesh.position.set(0, 0, -4);
			// vidMesh.userData.isDraggable = true;
			// vidMesh.name = 'e-triangle'
			// vidMesh.scale.set(.05, .05, .05);
			// scene.add(vidMesh)

			/// Video mesh group
			let vidSideAlpha = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[0]);
			vidSideAlpha.position.set(0, 14.33, -17.5);
			vidSideAlpha.rotateY(Math.PI); // 180° radians
			vidSideAlpha.rotateZ(Math.PI); // 180° radians
			vidSideAlpha.rotateX(0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidSideAlpha.material.side = THREE.DoubleSide; // render both sides
			let vidSideBeta = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[1]);
			vidSideBeta.position.set(0, 10, -15);
			vidSideBeta.rotateX(1.5708); // 90° in radians
			let vidSideGamma = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[2]);
			vidSideGamma.position.set(0, 14.33, -12.5);
			vidSideGamma.rotateX(-0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidGroup.add(vidSideAlpha);
			vidGroup.add(vidSideBeta);
			vidGroup.add(vidSideGamma);
			vidGroup.add(vidShapeSideOne);
			vidGroup.add(vidShapeSideTwo);
			vidGroup.userData.isDraggable = true;
			vidGroup.name = 'vidGroup';
			scene.add(vidGroup)
			// console.log(vidGroup)




			// 
			// video.src = 'https://cdn.cpixl.com/other/projectie_3.mp4';
			// video.crossOrigin = 'anonymous';
			video.load();
			video.play();
			video2.load();
			video2.play();
			video3.load();
			video3.play();





			// init mats, sounds and analysers
			objConfig.forEach(obj => {
				// create a new material with the color of the object
				mats[obj.name] = new THREE.MeshPhongMaterial({ color: obj.color, flatShading: true, shininess: 0 });
				// create a new mesh with that material
				meshes[obj.name] = new THREE.Mesh(sphere, mats[obj.name])
				meshes[obj.name].name = obj.name;
				// scene.add(meshes[obj.name]); // DONT ADD EACH OBJECT INDIVIDUALLY
				stemsGroup.add(meshes[obj.name]);

				// create audio sources, load from html and add to objects
				sounds[obj.name] = new THREE.PositionalAudio(listener);
				const currentSound = document.querySelector(`#${obj.name}`)
				sounds[obj.name].setMediaElementSource(currentSound).setRefDistance(refDist);
				currentSound.play();
				meshes[obj.name].add(sounds[obj.name]);

				// start analysers
				analysers[obj.name] = new THREE.AudioAnalyser(sounds[obj.name], 32);
			})

			// set positions of objects
			meshes['atmos'].position.set(- 250, 30, 100);
			meshes['bass'].position.set(- 200, 30, 100);
			meshes['drums'].position.set(- 150, 30, 100);
			meshes['guitars'].position.set(- 100, 30, 100);
			meshes['lq'].position.set(- 50, 30, 100);
			meshes['pads'].position.set(0, 30, 100);
			meshes['plucks'].position.set(50, 30, 100);
			meshes['tags'].position.set(100, 30, 100);
			meshes['vocals'].position.set(150, 30, 100);

			scene.add(stemsGroup); // ADD STEMS GROUP TO THE SCENE

			console.log({ mats })
			console.log({ meshes })
			console.log({ sounds })
			console.log({ analysers })


			// global ambient audio

			// const sound5 = new THREE.Audio(listener);
			// const utopiaElement = document.getElementById('utopia');
			// sound5.setMediaElementSource(utopiaElement);
			// sound5.setVolume(0.5);
			// utopiaElement.play();


			/// Raycaster
			raycaster = new THREE.Raycaster();
			///


			// ground
			const helper = new THREE.GridHelper(1000, 10, 0x444444, 0x444444);
			helper.position.y = 0.1;
			scene.add(helper);

			//

			const SoundControls = function () {
				this.master = listener.getMasterVolume();
				objConfig.forEach(obj => {
					this[obj.name] = sounds[obj.name].getVolume();
				})
			};



			const gui = new GUI();
			const soundControls = new SoundControls();
			// const generatorControls = new GeneratorControls();
			const volumeFolder = gui.addFolder('sound volume');
			// const generatorFolder = gui.addFolder('sound generator');

			volumeFolder.add(soundControls, 'master').min(0.0).max(1.0).step(0.01).onChange(function () {
				listener.setMasterVolume(soundControls.master);
			});

			// add controls for each sound loaded
			objConfig.forEach(obj => {
				volumeFolder.add(soundControls, obj.name, 0, 1, 0.01).onChange(value => {
					sounds[obj.name].setVolume(value);
				});
			})
			volumeFolder.open();

			///
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			/// webxr
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.shadowMap.enabled = true;
			renderer.xr.enabled = true;

			document.body.appendChild(renderer.domElement);
			//

			controls = new FirstPersonControls(camera, renderer.domElement);

			controls.movementSpeed = 20;
			controls.lookSpeed = 0.30;
			controls.noFly = false;
			controls.lookVertical = true;

			//

			window.addEventListener('resize', onWindowResize);

			animate();


			/// webxr stuff

			function onSelectStart(e) {
				this.userData.isSelecting = true;


				const controller = e.target;

				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				///! could be optimized slightly by adding all draggable objects to a group and only checking intersections on that group instead of the whole scene
				const intersects = raycaster.intersectObjects(scene.children, false);
				const intersectsVidGroup = raycaster.intersectObjects(vidGroup.children, false);
				// console.log({ intersectsVidGroup })

				/// standalone objects
				if (intersects.length > 0) {
					intersects.forEach(obj => {
						if (!obj.object.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

				}

				/// video group obj
				if (intersectsVidGroup.length > 0) {
					intersectsVidGroup.forEach(obj => {
						console.log(obj)
						if (!obj.object.parent.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object.parent;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

				}

			}

			function onSelectEnd(e) {
				/// 'this' is the controller group
				this.userData.isSelecting = false;

				const controller = e.target;

				if (controller.userData.selected !== undefined) {

					const object = controller.userData.selected;
					scene.attach(object);

					controller.userData.selected = undefined;

				}
			}

			/// init & render controller models
			/// populate the groups
			controllers = [renderer.xr.getController(0), renderer.xr.getController(1)]
			controllerGrips = [renderer.xr.getControllerGrip(0), renderer.xr.getControllerGrip(1)]
			const controllerModelFactory = new XRControllerModelFactory();
			// controller = renderer.xr.getController(0);

			/// adding event listeners
			controllers.forEach(controller => {
				controller.addEventListener('selectstart', onSelectStart);
				controller.addEventListener('selectend', onSelectEnd);
				controller.addEventListener('connected', function (event) {
					this.add(buildController(event.data));
				});
				controller.addEventListener('disconnected', function () {
					this.remove(this.children[0]);
				});
				scene.add(controller);
			})

			/// adding models so they're visible
			controllerGrips.forEach(controllerGrip => {
				controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
				scene.add(controllerGrip);
			});

			// controller.addEventListener('selectstart', onSelectStart);
			// controller.addEventListener('selectend', onSelectEnd);
			// controller.addEventListener('connected', function (event) {
			// 	this.add(buildController(event.data));
			// });
			// controller.addEventListener('disconnected', function () {
			// 	this.remove(this.children[0]);
			// });
			// scene.add(controller);


			// controllerGrip = renderer.xr.getControllerGrip(0);
			// controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
			// scene.add(controllerGrip);

			document.body.appendChild(VRButton.createButton(renderer));

			lyrics.startTime = performance.now();
			lyrics.lineIndex = 0;
			lyrics.ended = false;
			lyrics.timeOffset = 0;

			console.log(lyrics)

			scene.add(text)

			// Set properties to configure:
			text.text = 'Hi there!'
			text.fontSize = 4
			text.position.set(0, 10, 30)
			text.rotateY(Math.PI)
			text.color = 0xffbb00
			text.anchorX = 'center';

			// Update the rendering:
			text.sync()

		}

		function buildController(data) {

			let geometry, material;

			switch (data.targetRayMode) {

				case 'tracked-pointer':

					geometry = new THREE.BufferGeometry();
					geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
					geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

					material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

					return new THREE.Line(geometry, material);

				case 'gaze':

					geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
					material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
					return new THREE.Mesh(geometry, material);

			}

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

		}

		function animate() {

			// requestAnimationFrame(animate);
			// render();

			renderer.setAnimationLoop(render);

		}


		function render() {

			const delta = clock.getDelta();

			controls.update(delta);


			/// analysers
			stemsGroup.children.forEach(obj => {
				// console.log(obj)
				if (!obj?.isHighlighted) {
					mats[obj.name].emissive.r = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.g = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.b = analysers[obj.name].getAverageFrequency() / 256 * 2;
				}
			})


			/// lyrics

			lyrics.currentTime = performance.now();
			lyrics.timeDelta = parseInt(lyrics.currentTime - lyrics.startTime);

			// console.log(lyrics.timeDelta)
			// console.log(!lyrics?.lastLine)
			// console.log(lyrics.timeDelta >= lyrics.lines[0].startTimeMs)

			// if (!lyrics?.lastLine) {
			// 	lyrics.lineIndex = 0;
			// 	if (lyrics.lines[0].startTimeMs >= lyrics.timeDelta) {
			// 		lyrics.lastLine = lyrics.lines[lyrics.lineIndex].words;
			// 		console.log(lyrics.lastLine);
			// 	}
			// }
			// else {
			// 	if (lyrics.currentTime - lyrics.lastLine.endTimeMs > lyrics.lineIntervalMs) {
			// 		lyrics.lineIndex++;
			// 		if (lyrics.lineIndex < lyrics.lines.length) {
			// 			console.log(lyrics.lines[lyrics.lineIndex].words);
			// 		}
			// 	}
			// }


			if ((lyrics.timeDelta + lyrics.timeOffset) >= lyrics.lines[lyrics.lineIndex]?.startTimeMs && !lyrics.ended) {
				console.log(lyrics.lines[lyrics.lineIndex].words);

				text.text = lyrics.lines[lyrics.lineIndex].words;
				text.sync();
				lyrics.lineIndex++;
			}
			if (typeof lyrics.lines[lyrics.lineIndex] == 'undefined') { lyrics.ended = true }


			/// controller code
			// find intersections
			controllers.forEach(controller => {
				/// 'controller' is the controller object aka 'this' in the event listeners

				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				const intersects = raycaster.intersectObjects(stemsGroup.children, false);

				// console.log(controller)

				if (intersects.length > 0) {
					// console.log(intersects);
					// console.log(controller);

					/// is the object we're pointing at the same as the previous frame?
					if (controller.userData.INTERSECTED != intersects[0].object) {
						/// if not, remove the highlight from the previous object (if it exists)
						if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }

						/// set the color of the old object back to what it was
						if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);

						/// set the current object to be the new INTERSECTED object
						controller.userData.INTERSECTED = intersects[0].object;
						/// get the current color to revert to later when deselecting
						controller.userData.INTERSECTED.currentHex = controller.userData.INTERSECTED.material.emissive.getHex();
						/// modify the color of the object (apply highlight)
						controller.userData.INTERSECTED.material.emissive.setHex(0xffbb00);
						/// finally set object state to be highlighted
						controller.userData.INTERSECTED.isHighlighted = true;

					}

					/// is this the first time we're clicking on the object? (and are we not dragging an object)
					if (controller.userData.isSelecting && !controller.userData.isHolding && !controller.userData.selected) {
						/// set for next frame
						controller.userData.isHolding = true;
						controller.userData.intent = { holdLog: [], action: 0 };

						const volume = sounds[controller.userData.INTERSECTED.name].getVolume();

						switch (volume) {
							case 0:
								sounds[controller.userData.INTERSECTED.name].setVolume(1);
								controller.userData.intent.action = 1; /// update action if unmuting

								break;
							case 1:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
							default:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
						}
					} else if (!controller.userData.isSelecting && controller.userData.isHolding) {
						controller.userData.isHolding = false;
					}

					/// checks for user intent
					if (controller.userData.isSelecting && controller.userData.isHolding && !controller.userData.selected) {

						if (controller.userData.intent?.holdLog.at(-1) != intersects[0].object) {
							if (controller.userData.intent.holdLog == undefined) {
								controller.userData.intent.holdLog = [];
							}
							controller.userData.intent.holdLog.push(intersects[0].object)
						} else {
							sounds[controller.userData.INTERSECTED.name].setVolume(controller.userData.intent.action);

						}
					}

				} else {
					/// clean up and reset currently highlighted objects to their original color/state
					if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }
					if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);
					controller.userData.INTERSECTED = undefined;
				}
			})


			renderer.render(scene, camera);
		}

	</script>

</body>

</html>