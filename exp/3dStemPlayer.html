<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webaudio - sandbox</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<!-- keep filesize low to avoid them from being slow -->
	<audio id="atmos" preload="auto" style="display: none">
		<source src="sounds/wdyf/atmos.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/atmos.wav" type="audio/wav">
	</audio>
	<audio id="bass" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/bass.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/bass.wav" type="audio/wav">
	</audio>
	<audio id="drums" preload="auto" style="display: none">
		<source src="sounds/wdyf/drums.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/drums.wav" type="audio/wav">
	</audio>
	<audio id="guitars" preload="auto" style="display: none">
		<source src="sounds/wdyf/guitars.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/guitars.wav" type="audio/wav">
	</audio>
	<audio id="lq" preload="auto" style="display: none">
		<source src="sounds/wdyf/lq.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/lq.wav" type="audio/wav">
	</audio>
	<audio id="pads" preload="auto" style="display: none">
		<source src="sounds/wdyf/pads.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/pads.wav" type="audio/wav">
	</audio>
	<audio id="plucks" preload="auto" style="display: none">
		<source src="sounds/wdyf/plucks.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/plucks.wav" type="audio/wav">
	</audio>
	<audio id="tags" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/tags.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/tags.wav" type="audio/wav">
	</audio>
	<audio id="vocals" loop preload="auto" style="display: none">
		<source src="sounds/wdyf/vocals.mp3" type="audio/mpeg">
		<source src="sounds/wdyf/vocals.wav" type="audio/wav">
	</audio>

	<div id="overlay">
		<button id="startButton">Play</button>
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';
		import { GUI } from './jsm/libs/lil-gui.module.min.js';
		import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';
		import { VRButton } from './jsm/webxr/VRButton.js';
		import { XRControllerModelFactory } from './jsm/webxr/XRControllerModelFactory.js';


		let camera, controls, scene, raycaster, renderer, light;
		let controller, controllerGrip;
		let INTERSECTED;
		const tempMatrix = new THREE.Matrix4();


		let mats = [];
		let meshes = [];
		let sounds = [];
		let analysers = [];

		// groups
		let stemsGroup = new THREE.Group();

		const clock = new THREE.Clock();

		const startButton = document.getElementById('startButton');
		startButton.addEventListener('click', init);

		const refDist = 50; // distance from where to start applying volume reduction 
		const objConfig = [
			{ name: 'atmos', color: 0xDDD3C3, sound: 'atmos', },
			{ name: 'bass', color: 0x812ADE, sound: 'bass', },
			{ name: 'drums', color: 0x3444E3, sound: 'drums', },
			{ name: 'guitars', color: 0xC714D6, sound: 'guitars', },
			{ name: 'lq', color: 0xE4406E, sound: 'lq', },
			{ name: 'pads', color: 0xFFA211, sound: 'pads', },
			{ name: 'plucks', color: 0xFFDE4A, sound: 'plucks', },
			{ name: 'tags', color: 0x02D37A, sound: 'tags', },
			{ name: 'vocals', color: 0x51C5C5, sound: 'vocals', },]

		function init() {

			const overlay = document.getElementById('overlay');
			overlay.remove();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, .1, 10000);
			camera.position.set(0, 30, 200);

			const listener = new THREE.AudioListener();
			camera.add(listener);

			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2(0x000000, 0.0025);


			const light = new THREE.DirectionalLight(0xffffff);
			light.position.set(1, 1, 1).normalize();
			scene.add(light);


			const sphere = new THREE.SphereGeometry(20, 32, 16);


			// init mats, sounds and analysers

			console.log(mats['atmos'])

			objConfig.forEach(obj => {
				// create a new material with the color of the object
				mats[obj.name] = new THREE.MeshPhongMaterial({ color: obj.color, flatShading: true, shininess: 0 });
				// create a new mesh with that material
				meshes[obj.name] = new THREE.Mesh(sphere, mats[obj.name])
				meshes[obj.name].name = obj.name;
				// scene.add(meshes[obj.name]); // DONT ADD EACH OBJECT INDIVIDUALLY
				stemsGroup.add(meshes[obj.name]);

				// create audio sources, load from html and add to objects
				sounds[obj.name] = new THREE.PositionalAudio(listener);
				const currentSound = document.querySelector(`#${obj.name}`)
				sounds[obj.name].setMediaElementSource(currentSound).setRefDistance(refDist);
				currentSound.play();
				meshes[obj.name].add(sounds[obj.name]);

				// start analysers
				analysers[obj.name] = new THREE.AudioAnalyser(sounds[obj.name], 32);
			})

			// set positions of objects
			meshes['atmos'].position.set(- 250, 30, 0);
			meshes['bass'].position.set(- 200, 30, 0);
			meshes['drums'].position.set(- 150, 30, 0);
			meshes['guitars'].position.set(- 100, 30, 0);
			meshes['lq'].position.set(- 50, 30, 0);
			meshes['pads'].position.set(0, 30, 0);
			meshes['plucks'].position.set(50, 30, 0);
			meshes['tags'].position.set(100, 30, 0);
			meshes['vocals'].position.set(150, 30, 0);

			scene.add(stemsGroup); // ADD STEMS GROUP TO THE SCENE

			console.log({ mats })
			console.log({ meshes })
			console.log({ sounds })
			console.log({ analysers })


			// global ambient audio

			// const sound5 = new THREE.Audio(listener);
			// const utopiaElement = document.getElementById('utopia');
			// sound5.setMediaElementSource(utopiaElement);
			// sound5.setVolume(0.5);
			// utopiaElement.play();


			/// Raycaster
			raycaster = new THREE.Raycaster();
			///


			// ground
			const helper = new THREE.GridHelper(1000, 10, 0x444444, 0x444444);
			helper.position.y = 0.1;
			scene.add(helper);

			//

			const SoundControls = function () {
				this.master = listener.getMasterVolume();
				objConfig.forEach(obj => {
					this[obj.name] = sounds[obj.name].getVolume();
				})
			};



			const gui = new GUI();
			const soundControls = new SoundControls();
			// const generatorControls = new GeneratorControls();
			const volumeFolder = gui.addFolder('sound volume');
			// const generatorFolder = gui.addFolder('sound generator');

			volumeFolder.add(soundControls, 'master').min(0.0).max(1.0).step(0.01).onChange(function () {
				listener.setMasterVolume(soundControls.master);
			});

			// add controls for each sound loaded
			objConfig.forEach(obj => {
				volumeFolder.add(soundControls, obj.name, 0, 1, 0.01).onChange(value => {
					sounds[obj.name].setVolume(value);
				});
			})
			volumeFolder.open();

			///
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			/// webxr
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.xr.enabled = true;

			document.body.appendChild(renderer.domElement);
			//

			controls = new FirstPersonControls(camera, renderer.domElement);

			controls.movementSpeed = 150;
			controls.lookSpeed = 0.10;
			controls.noFly = true;
			controls.lookVertical = true;

			//

			window.addEventListener('resize', onWindowResize);

			animate();


			/// webxr stuff

			function onSelectStart() {
				this.userData.isSelecting = true;
			}

			function onSelectEnd() {
				this.userData.isSelecting = false;
			}

			controller = renderer.xr.getController(0);
			controller.addEventListener('selectstart', onSelectStart);
			controller.addEventListener('selectend', onSelectEnd);
			controller.addEventListener('connected', function (event) {

				this.add(buildController(event.data));

			});
			controller.addEventListener('disconnected', function () {

				this.remove(this.children[0]);

			});
			scene.add(controller);

			const controllerModelFactory = new XRControllerModelFactory();

			controllerGrip = renderer.xr.getControllerGrip(0);
			controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
			scene.add(controllerGrip);

			document.body.appendChild(VRButton.createButton(renderer));


		}

		function buildController(data) {

			let geometry, material;

			switch (data.targetRayMode) {

				case 'tracked-pointer':

					geometry = new THREE.BufferGeometry();
					geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
					geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

					material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

					return new THREE.Line(geometry, material);

				case 'gaze':

					geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
					material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
					return new THREE.Mesh(geometry, material);

			}

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

		}

		function animate() {

			// requestAnimationFrame(animate);
			// render();

			renderer.setAnimationLoop(render);

		}


		function render() {

			const delta = clock.getDelta();

			controls.update(delta);

			stemsGroup.children.forEach(obj => {
				console.log(obj)
				if (!obj?.isHighlighted) {
					mats[obj.name].emissive.r = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.g = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.b = analysers[obj.name].getAverageFrequency() / 256 * 2;
				}
			})


			/////////////////////////////////////////// WEBXR

			// if (controller.userData.isSelecting === true) {

			// 	console.log(scene.children)
			// 	console.log(meshes)

			// 	const 
			// 	const cube = room.children[0];
			// 	room.remove(cube);

			// 	cube.position.copy(controller.position);
			// 	cube.userData.velocity.x = (Math.random() - 0.5) * 0.02 * delta;
			// 	cube.userData.velocity.y = (Math.random() - 0.5) * 0.02 * delta;
			// 	cube.userData.velocity.z = (Math.random() * 0.01 - 0.05) * delta;
			// 	cube.userData.velocity.applyQuaternion(controller.quaternion);
			// 	room.add(cube);

			// }

			// find intersections

			tempMatrix.identity().extractRotation(controller.matrixWorld);

			raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
			raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

			const intersects = raycaster.intersectObjects(stemsGroup.children, false);

			// if (intersects.length > 0) {
			// 	console.log(intersects);

			// 	if (INTERSECTED) {
			// 		// if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
			// 		// INTERSECTED = intersects[0].object;
			// 		// INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
			// 		// INTERSECTED.material.emissive.setHex(0xff0000);
			// 	}

			// } else {

			// 	if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
			// 	INTERSECTED = undefined;

			// }

			if (intersects.length > 0) {
				console.log(intersects);

				if (INTERSECTED != intersects[0].object) {
					if (INTERSECTED != undefined) { INTERSECTED.isHighlighted = false; }


					if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

					INTERSECTED = intersects[0].object;
					INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
					INTERSECTED.material.emissive.setHex(0xff0000);

					INTERSECTED.isHighlighted = true;

				}

			} else {
				if (INTERSECTED != undefined) { INTERSECTED.isHighlighted = false; }
				if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

				INTERSECTED = undefined;

			}

			renderer.render(scene, camera);
		}

	</script>

</body>

</html>