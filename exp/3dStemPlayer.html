<!DOCTYPE html>
<html lang="en">

<head>
	<title>The virtual soundscape - Phenomena</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<link rel="shortcut icon" href="https://p3-blog.corruptedpixl.com/assets/favicons/favicon.svg">
</head>

<body>

	<!-- keep filesize low to avoid them from being slow -->
	<!-- <audio id="atmos" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/atmos.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/atmos.wav" type="audio/wav">
	</audio>
	<audio id="bass" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/bass.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/bass.wav" type="audio/wav">
	</audio>
	<audio id="drums" preload="auto" style="display: none">
		<source src="media/audio/wdyf/drums.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/drums.wav" type="audio/wav">
	</audio>
	<audio id="guitars" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/guitars.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/guitars.wav" type="audio/wav">
	</audio>
	<audio id="lq" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/lq.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/lq.wav" type="audio/wav">
	</audio>
	<audio id="pads" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/pads.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/pads.wav" type="audio/wav">
	</audio>
	<audio id="plucks" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/plucks.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/plucks.wav" type="audio/wav">
	</audio>
	<audio id="tags" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/tags.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/tags.wav" type="audio/wav">
	</audio>
	<audio id="vocals" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/vocals.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/vocals.wav" type="audio/wav">
	</audio> -->


	<div id='audioContainer'></div>
	<div id='videoContainer'></div>
	<!-- <video id="video" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP1-drums.mp4" type="video/mp4" crossorigin="*">
	</video>
	<video id="video2" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP2-synths.mp4" type="video/mp4" crossorigin="*">
	</video>
	<video id="video3" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP3-guitars.mp4" type="video/mp4" crossorigin="*">
	</video> -->

	<div id="overlay">
		<h1>Welcome to Phenomena: behind the music</h1>
		<p>This WebXR experience will show you how Phenomena came to be and allow you to play with the songs.</p>
		<button id="startButton">Start the experience</button>
		<p id="loading">Loading...</p>
		<p>You can view the experience in your browser by pressing this button or in VR by pressing the "enter VR" button at the bottom once the experience is started.</p>
		<p>Special thanks to Zanski for allowing me to use the stems, artwork and videos for this project!</p>
	</div>

	<script type="module">

		import { Text } from 'https://cdn.skypack.dev/troika-three-text';

		import * as THREE from 'https://cdn.skypack.dev/three';
		import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/lil-gui.module.min.js';
		import { FirstPersonControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/FirstPersonControls.js';
		import { VRButton } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/VRButton.js';
		import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/XRControllerModelFactory.js';
		import { GLTFLoader } from 'https://cdn.skypack.dev/three/examples/jsm/loaders/GLTFLoader.js';

		const lyrics = await fetch('lyrics/forest-spirit-sound.json').then(response => response.json());

		let camera, controls, scene, raycaster, renderer, light, listener, textureEquirec, waterTexture;
		let controller, controllerGrip;
		let playListJson, albumArt, albumTitle, artist;
		let currentStems = [];
		let currentLyrics = [];
		let globalTime = { value: 0 };
		const tempMatrix = new THREE.Matrix4();
		const text = new Text();

		let mats = [];
		let meshes = [];
		let sounds = [];
		let videos = [];
		let analysers = [];
		let HDRIS = [];

		let controllers = [];
		let controllerGrips = [];

		// groups
		let stemsGroup = new THREE.Group();
		let vidGroup = new THREE.Group();

		const clock = new THREE.Clock();

		const startButton = document.getElementById('startButton');
		startButton.addEventListener('click', init);

		const vidConfig = ['video', 'video2', 'video3']
		const HDRIConfig = ['white', 'black', 'lines', 'sat', 'sat2', 'dark_white', 'dark_black', 'dark_dark',]

		const refDist = 50; // distance from where to start applying volume reduction 
		const objConfig = [
			{ name: 'atmos', color: 0xDDD3C3, sound: 'atmos', },
			{ name: 'bass', color: 0x812ADE, sound: 'bass', },
			{ name: 'drums', color: 0x3444E3, sound: 'drums', },
			{ name: 'guitars', color: 0xC714D6, sound: 'guitars', },
			{ name: 'lq', color: 0xE4406E, sound: 'lq', },
			{ name: 'pads', color: 0xFFA211, sound: 'pads', },
			{ name: 'plucks', color: 0xFFDE4A, sound: 'plucks', },
			{ name: 'tags', color: 0x02D37A, sound: 'tags', },
			{ name: 'vocals', color: 0x51C5C5, sound: 'vocals', },]


		const getPlaylist = async (url) => {
			// playListJson = await fetch(url).then(response => response.json());
			// return playListJson;
			return await fetch(url).then(response => response.json());
		}
		const initPlaylist = async () => {
			playListJson = await getPlaylist('media/json/playlist.json');
			albumArt = playListJson.albumArt;
			albumTitle = playListJson.album;
			artist = playListJson.artist;

			preloadImgs([albumArt]); /// allows to load multiple sources if needed
			preloadVideos(playListJson.videos); /// loads all videos and appends them to the dom to access later
			preloadAudio()
		}

		const preloadImgs = async (imgs) => {
			imgs.forEach(async img => {
				const image = new Image();
				image.src = img;
				return image;
			})
		}

		const preloadVideos = (videos) => {
			// videos.map(video => {
			// 	const video = new Video();
			// 	image.src = img;
			// 	console.log(image)
			// 	document.querySelector('body').appendChild(image);
			// 	return image;
			// })
			const $videoContainer = document.querySelector('#videoContainer');
			$videoContainer.innerHTML = videos.map(video => `
			<video id="${video.id}" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
				<source src="${video.url}" type="video/mp4" crossorigin="*">
			</video>`
			).join(``)
		}

		const preloadAudio = () => {
			const defaultTrack = 9;
			loadTrack(playListJson.tracks[defaultTrack]);
		}

		const loadTrack = (track) => {
			currentStems = [];
			const $audioContainer = document.querySelector('#audioContainer');
			// $audioContainer.innerHTML = track.stems.map(stem => `
			// <audio id="${stem}" loop preload="auto" style="display: none">
			// 	<source src="${track.stemsPath}${stem}.mp3" type="audio/mpeg">
			// </audio>`
			// ).join(``)
			console.log('%c%s', 'color: #9FE3FF', `Now loading: ${track.title}`);
			track.stems.forEach(stem => {
				const audio = new Audio();
				audio.src = `${track.stemsPath}${stem.name}.mp3`;
				audio.loop = true;
				audio.name = stem.name;
				$audioContainer.appendChild(audio);
				audio.oncanplaythrough = (e) => {
					const $loading = document.querySelector('#loading');
					currentStems[audio.name] = { ...stem, "audio": audio };
					console.log('%c%s', 'color: #4AF2FF', `Loaded ${audio.name}`);
					if (Object.keys(currentStems).length === track.stems.length) {
						if ($loading) $loading.innerHTML = 'Loaded all stems!'
						console.log('%c%s', 'color: #1F8BFF', `All stems loaded.`);

						// if (!document.getElementById('overlay')) {
						// 	console.log(currentStems);
						// 	initStems(currentStems);
						// }
					}
				};
				// return audio;
			})
		}

		const unloadAudio = () => {
			const $audioContainer = document.querySelector('#audioContainer');
			// for (const stem in currentStems) {
			// 	currentStems[stem].audio.pause();
			// }
			$audioContainer.innerHTML = '';


			// for (const mesh in meshes) {
			// }
			// console.log(meshes[mesh])
			// const object = scene.getObjectByProperty('uuid', meshes[mesh].uuid);
			const stemsGroup = scene.getObjectByProperty('name', 'stemsGroup');
			console.log(stemsGroup)
			let stemsToBeRemoved = [...stemsGroup.children]; /// make a clone of the children to loop over otherwise the array will shorten during the loop and this skip every 2nd item
			for (const stem in stemsToBeRemoved) {
				console.log(stemsToBeRemoved[stem])
				const stemObject = stemsToBeRemoved[stem];
				stemObject.geometry.dispose();
				stemObject.material.dispose();
				// stemObject.children.forEach(child => {
				// 	child?.source?.disconnect();
				// });
				delete mats[stemsToBeRemoved[stem].name]
				delete meshes[stemsToBeRemoved[stem].name]
				delete sounds[stemsToBeRemoved[stem].name]
				delete analysers[stemsToBeRemoved[stem].name]
				stemObject.removeFromParent();
			}
			stemsToBeRemoved = [];


			scene.remove(stemsGroup);
			console.log(stemsGroup)
			// mats = [];
			// meshes = [];
			// sounds = [];
			// analysers = [];
			renderer.renderLists.dispose();

			console.log({ mats })
			console.log({ meshes })
			console.log({ sounds })
			console.log({ analysers })
		}

		initPlaylist();

		const initScene = () => {
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, .1, 10000);
			camera.position.set(0, 20, 0);

			listener = new THREE.AudioListener();
			camera.add(listener);

			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2(0x000000, 0.0025);

			// const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
			const light = new THREE.DirectionalLight(0xffffbb);
			light.position.set(100, 30, -10).normalize();
			light.castShadow = true;
			scene.add(light);

			/// ground
			const helper = new THREE.GridHelper(1000, 10, 0x444444, 0x444444);
			helper.position.y = 0.1;
			scene.add(helper);

			/// Raycaster
			raycaster = new THREE.Raycaster();

			///////////////////////
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			/// enable webxr
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.shadowMap.enabled = true;
			renderer.xr.enabled = true;
			document.body.appendChild(renderer.domElement);
			// initStems(objConfig)
		}

		const initStems = (currentStems) => {
			const sphere = new THREE.SphereGeometry(20, 32, 16);
			let note;
			/////////////// GLTF
			const loader = new GLTFLoader().setPath('models/');
			loader.load('note_gold.gltf', (gltf) => {
				// console.log(gltf)
				const noteModel = gltf.scene;
				// const noteModel = new THREE.Mesh(gltf.scene.children[0], new THREE.MeshLambertMaterial({ color: 0xDDD3C3, envMap: textureEquirec, reflectivity: 1 }));
				noteModel.envMap = textureEquirec;
				// noteModel.children[0].material = new THREE.MeshLambertMaterial({ color: 0xDDD3C3, envMap: textureEquirec, reflectivity: 1 });
				noteModel.children[0].material.envMap = textureEquirec;
				// noteModel.needsUpdate = true;
				// scene.add(noteModel);
				note = noteModel.children[0].geometry;
				loadStems()
			});
			///////////////

			const loadStems = () => {

				// init mats, sounds and analysers
				// currentStems.forEach(stem => {
				// console.log(currentStems)
				const populateArrays = new Promise((resolve, reject) => {
					for (const stem in currentStems) {
						// create a new material with the color of the object
						mats[currentStems[stem].name] = new THREE.MeshPhongMaterial({ color: currentStems[stem].color, flatShading: true, shininess: 0 });
						// create a new mesh with that material
						// meshes[obj.name] = new THREE.Mesh(sphere, mats[obj.name]) /// old mesh
						meshes[currentStems[stem].name] = new THREE.Mesh(note, mats[currentStems[stem].name])
						/// TODO change color of included material in gltf so the environment is reflected. 
						meshes[currentStems[stem].name].name = currentStems[stem].name;
						// scene.add(meshes[stem.name]); // DONT ADD EACH OBJECT INDIVIDUALLY
						stemsGroup.add(meshes[currentStems[stem].name]);

						// create audio sources, load from html and add to stemects
						sounds[currentStems[stem].name] = new THREE.PositionalAudio(listener);
						// const currentSound = document.querySelector(`#${currentStems[stem].name}`) /// old loading func
						const currentSound = currentStems[stem].audio;
						sounds[currentStems[stem].name].setMediaElementSource(currentSound).setRefDistance(refDist);
						// currentSound.play(); /// dont play here but after everything's loaded
						meshes[currentStems[stem].name].add(sounds[currentStems[stem].name]);
						// start analysers
						analysers[currentStems[stem].name] = new THREE.AudioAnalyser(sounds[currentStems[stem].name], 32);
					}
					resolve()
				})
				populateArrays.then(res => {
					console.log(meshes)
					// set positions of objects
					meshes['atmos'].position.set(- 250, 30, 100);
					meshes['bass'].position.set(- 200, 30, 100);
					meshes['drums'].position.set(- 150, 30, 100);
					meshes['guitars'].position.set(- 100, 30, 100);
					meshes['lq'].position.set(- 50, 30, 100);
					meshes['pads'].position.set(0, 30, 100);
					meshes['plucks'].position.set(50, 30, 100);
					meshes['tags'].position.set(100, 30, 100);
					meshes['vocals'].position.set(150, 30, 100);
				})

				stemsGroup.name = 'stemsGroup';
				scene.add(stemsGroup); // ADD STEMS GROUP TO THE SCENE

				initGui()
				for (const stem in currentStems) { currentStems[stem].audio.play() } /// Finally start playing them all (as close as possible) at the same time
			}
		}

		const initVideoGroup = (vidConfig) => {
			// VIDEOooo
			const vidTextures = [];

			vidConfig.forEach(video => {
				const currentVid = document.querySelector(`#${video}`);
				// videos[video] = currentVid;
				videos.push(currentVid);
				vidTextures.push(new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(currentVid), }));
				// console.log(currentVid)
				// console.log(videos)
			});
			// const video = document.querySelector('#video');
			// const video2 = document.querySelector('#video2');
			// const video3 = document.querySelector('#video3');



			// const vidTextures = [
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video), }), /// side: THREE.DoubleSide  can prob be omitted (NEEDS TESTING)
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2), }), ///  side: THREE.DoubleSide can prob be omitted (NEEDS TESTING)
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3), }), ///  side: THREE.DoubleSide can prob be omitted (NEEDS TESTING)
			// ];

			// const vidTex = new THREE.VideoTexture(video);
			// // vidTex.needsUpdate;
			// vidTex.minFilter = THREE.LinearFilter;
			// vidTex.magFilter = THREE.LinearFilter;
			// vidTex.format = THREE.RGBFormat;
			// // vidTex.wrapS = THREE.CubeReflectionMapping;
			// // vidTex.wrapT = THREE.CubeReflectionMapping;
			// vidTex.repeat.set(100, 100);
			// // video.crossOrigin = 'anonymous';

			const triangleSize = .5;
			const triangle = new THREE.Shape(); // create a triangle
			triangle.moveTo(10 * triangleSize, 0); // right point
			triangle.lineTo(-9.4 * triangleSize, 0); // left point
			triangle.lineTo(0.16, 16.8 * triangleSize); // top point
			triangle.lineTo(10 * triangleSize, 0); // back to start to close the shape

			const vidShapeSideOne = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			const vidShapeSideTwo = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			vidShapeSideOne.position.set(10, 10.08, -14.85);
			vidShapeSideTwo.position.set(-10, 10.08, -14.85);
			vidShapeSideOne.rotateY(Math.PI / 2); // 180° radians
			vidShapeSideTwo.rotateY(Math.PI / 2); // 180° radians
			// scene.add(vidShapeSideOne);
			// scene.add(vidShapeSideTwo);

			// let vidMesh = new THREE.Mesh(
			// 	// new THREE.PlaneGeometry(20, 10),
			// 	new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: 30, }), // extrude triangle
			// 	// new THREE.MeshBasicMaterial({ map: vidTex }));
			// 	// extrudedTriangle,
			// 	[
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffbb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00bb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x0000ff }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffffff }),
			// 	]);
			// // new THREE.MeshFaceMaterial(vidTextures));
			// // new THREE.MeshBasicMaterial({ color: 0xffbb00 }));

			// vidMesh.position.set(0, 0, -4);
			// vidMesh.userData.isDraggable = true;
			// vidMesh.name = 'e-triangle'
			// vidMesh.scale.set(.05, .05, .05);
			// scene.add(vidMesh)

			/// Video mesh group
			let vidSideAlpha = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[0]);
			vidSideAlpha.name = 'vidSideAlpha';
			vidSideAlpha.position.set(0, 14.33, -17.5);
			vidSideAlpha.rotateY(Math.PI); // 180° radians
			vidSideAlpha.rotateZ(Math.PI); // 180° radians
			vidSideAlpha.rotateX(0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidSideAlpha.material.side = THREE.DoubleSide; // render both sides
			let vidSideBeta = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[1]);
			vidSideBeta.name = 'vidSideBeta';
			vidSideBeta.position.set(0, 10, -15);
			vidSideBeta.rotateX(1.5708); // 90° in radians
			let vidSideGamma = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[2]);
			vidSideGamma.name = 'vidSideGamma';
			vidSideGamma.position.set(0, 14.33, -12.5);
			vidSideGamma.rotateX(-0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidGroup.add(vidSideAlpha);
			vidGroup.add(vidSideBeta);
			vidGroup.add(vidSideGamma);
			vidGroup.add(vidShapeSideOne);
			vidGroup.add(vidShapeSideTwo);
			vidGroup.userData.isDraggable = true;
			vidGroup.name = 'vidGroup';
			vidGroup.scale.set(.1, .1, .1);
			scene.add(vidGroup);

			videos.forEach(video => {
				video.load();
				video.play();
			});

			// video.load();
			// video.play();
			// video2.load();
			// video2.play();
			// video3.load();
			// video3.play();

		}

		const initGui = () => {
			const SoundControls = function () {
				this.master = listener.getMasterVolume();
				objConfig.forEach(obj => {
					this[obj.name] = sounds[obj.name].getVolume();
				})
			};


			const gui = new GUI();
			const soundControls = new SoundControls();
			// const generatorControls = new GeneratorControls();
			const volumeFolder = gui.addFolder('sound volume');
			// const generatorFolder = gui.addFolder('sound generator');

			volumeFolder.add(soundControls, 'master').min(0.0).max(1.0).step(0.01).onChange(function () {
				listener.setMasterVolume(soundControls.master);
				////// TEMP REMOVE
				if (soundControls.master < .3) { scene.background = HDRIS.dark_white; }
				if (soundControls.master > .3 && soundControls.master < .6) { scene.background = HDRIS.dark_dark; }
				if (soundControls.master > .6) { scene.background = HDRIS.sat2; }
			});

			// add controls for each sound loaded
			objConfig.forEach(obj => {
				volumeFolder.add(soundControls, obj.name, 0, 1, 0.01).onChange(value => {
					sounds[obj.name].setVolume(value);
				});
			})
			volumeFolder.open();
		}

		const initControllers = () => {
			/// webxr stuff
			function onSelectStart(e) {
				this.userData.isSelecting = true;


				const controller = e.target;

				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				///! could be optimized slightly by adding all draggable objects to a group and only checking intersections on that group instead of the whole scene
				const intersects = raycaster.intersectObjects(scene.children, false);
				const intersectsVidGroup = raycaster.intersectObjects(vidGroup.children, false);
				// console.log({ intersectsVidGroup })

				/// standalone objects
				if (intersects.length > 0) {
					intersects.forEach(obj => {
						if (!obj.object.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

				}

				/// video group obj
				if (intersectsVidGroup.length > 0) {

					if (this.userData?.videoGroup?.lastVideoObj === intersectsVidGroup[0].object && performance.now() - this.userData?.videoGroup?.lastClick <= 400) {
						// console.log(parseInt(performance.now()))
						// console.log(this.userData.videoGroup)
						switch (intersectsVidGroup[0].object.name) {
							case 'vidSideAlpha':
								videos[0].muted = !videos[0].muted;
								break;
							case 'vidSideBeta':
								videos[1].muted = !videos[1].muted;
								break;
							case 'vidSideGamma':
								videos[2].muted = !videos[2].muted;
								break;

							default:
								break;
						}
					}

					intersectsVidGroup.forEach(obj => {
						if (!obj.object.parent.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object.parent;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

					this.userData.videoGroup = {
						lastVideoObj: intersectsVidGroup[0].object,
						lastClick: performance.now()
					}
				}

			}

			function onSelectEnd(e) {
				/// 'this' is the controller group
				this.userData.isSelecting = false;

				const controller = e.target;

				if (controller.userData.selected !== undefined) {

					const object = controller.userData.selected;
					scene.attach(object);

					controller.userData.selected = undefined;

				}
			}

			/// init & render controller models
			/// populate the groups
			controllers = [renderer.xr.getController(0), renderer.xr.getController(1)]
			controllerGrips = [renderer.xr.getControllerGrip(0), renderer.xr.getControllerGrip(1)]
			const controllerModelFactory = new XRControllerModelFactory();
			// controller = renderer.xr.getController(0);

			/// adding event listeners
			controllers.forEach(controller => {
				controller.addEventListener('selectstart', onSelectStart);
				controller.addEventListener('selectend', onSelectEnd);
				controller.addEventListener('connected', function (event) {
					this.add(buildController(event.data));
				});
				controller.addEventListener('disconnected', function () {
					this.remove(this.children[0]);
				});
				scene.add(controller);
			})

			/// adding models so they're visible
			controllerGrips.forEach(controllerGrip => {
				controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
				scene.add(controllerGrip);
			});

			// controller.addEventListener('selectstart', onSelectStart);
			// controller.addEventListener('selectend', onSelectEnd);
			// controller.addEventListener('connected', function (event) {
			// 	this.add(buildController(event.data));
			// });
			// controller.addEventListener('disconnected', function () {
			// 	this.remove(this.children[0]);
			// });
			// scene.add(controller);


			// controllerGrip = renderer.xr.getControllerGrip(0);
			// controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
			// scene.add(controllerGrip);
		}

		const initLyrics = () => {
			lyrics.startTime = performance.now();
			lyrics.lineIndex = 0;
			lyrics.ended = false;
			lyrics.timeOffset = 0;

			console.log(lyrics)

			scene.add(text)

			// Set properties to configure:
			text.text = 'Hi there!'
			text.fontSize = 3
			text.font = 'https://cdn.cpixl.com/fonts/next/OTF/Next%20Book/NextBook-Medium.otf'
			text.position.set(0, 10, 30)
			text.rotateY(Math.PI)
			text.color = 0xffbb00
			text.anchorX = 'center';

			// Update the rendering:
			text.sync()
		}

		const initFloor = () => {
			/////////////// shader
			const shader = `
			#define PI 3.14159
			#define magic 1000.0

			uniform float time;
			varying vec2 vUv;

			void main( void ) {

				float v = 0.0;

				// vec2 position = ( gl_FragCoord.xy / resolution.xy );
				vec2 position = - 1.0 + 2.0 * vUv;

				// 'moving left effect'
				v += sin(position.x * 10.0 + time);


				// 'rotation effect' thingy (changes angle with time)
				v += sin(10.0 * (position.x * sin(time / 2.0)+position.y*cos(time/3.0))+time);

				// ???
				position.x = position.x + 0.5 * sin (time / 5.0);
				position.y = position.y + 0.5 * cos (time / 3.0);
				v += sin(sqrt(magic * (pow(position.x, 2.0) + pow(position.y, 2.0)) + 1.0 + time));	


				//	v = v / 2.0;

				// 'color palette' except not really
				// rgb-ish
				vec3 col = vec3(sin(v*PI), sin(v*PI + 2.0*PI/3.0), sin(v*PI + 4.0 * PI / 3.0));

				// experiment
				// vec3 col = vec3(v * 5.0 * PI, v * 5.0 * PI, v * 5.0 * PI);


				gl_FragColor = vec4(col*0.5 + 0.5, 1);
				
				// vec2 position = - 1.0 + 2.0 * vUv;
				// float red = abs( sin( position.x * position.y + time / 5.0 ) );
				// float green = abs( sin( position.x * position.y + time / 4.0 ) );
				// float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				// gl_FragColor = vec4( red, green, blue, 1.0 );

			}
						`

			const material = new THREE.ShaderMaterial({
				uniforms: {

					time: globalTime,
					resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }

				},
				vertexShader: `varying vec2 vUv;
								void main(){
								vUv = uv;
								gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
								}`,
				fragmentShader: shader
			});

			const testPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(10000, 10000),
				material
			);

			scene.add(testPlane);
			testPlane.rotateX(- Math.PI / 2)
			testPlane.position.set(0, -150, 0)
			////////////////


			/////////////// HDRI
			const textureLoader = new THREE.TextureLoader();
			HDRIConfig.forEach(HDRI => {
				const currentHDRI = textureLoader.load(`textures/hdri-${HDRI}.png`);
				currentHDRI.mapping = THREE.EquirectangularReflectionMapping;
				currentHDRI.encoding = THREE.sRGBEncoding;

				HDRIS[HDRI] = currentHDRI;
			})

			/////////// WATER TEXTURE
			waterTexture = textureLoader.load(`textures/waternormals.jpg`);
			waterTexture.magFilter = THREE.NearestFilter;
			waterTexture.wrapT = THREE.RepeatWrapping;
			waterTexture.wrapS = THREE.RepeatWrapping;
			waterTexture.repeat.set(800, 2000.5);

			// const textureLoader = new THREE.TextureLoader();
			// textureEquirec = textureLoader.load('textures/hdri-skygone.png');
			// textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
			// textureEquirec.encoding = THREE.sRGBEncoding;
			scene.background = HDRIS.dark_dark;
			///////////////

			//////////////// Glass plane
			const glassPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(2000, 2000),
				new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 1,
					ior: 1.1,
					alpha: .5,
					alphaMap: waterTexture,
					envMap: HDRIS.dark_white,
					envMapIntensity: 1,
					transmission: 1,
					specularIntensity: 1,
					specularColor: 0xffffff,
					opacity: 1,
					thickness: 2,
					side: THREE.DoubleSide,
					transparent: true,
					clearcoat: 1,
					clearcoatMap: waterTexture,

				}))

			glassPlane.rotateX(- Math.PI / 2)
			// glassPlane.receiveShadow
			scene.add(glassPlane);
			///////////////
		}

		const buildController = (data) => {

			let geometry, material;

			switch (data.targetRayMode) {

				case 'tracked-pointer':

					geometry = new THREE.BufferGeometry();
					geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
					geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

					material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

					return new THREE.Line(geometry, material);

				case 'gaze':

					geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
					material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
					return new THREE.Mesh(geometry, material);

			}

		}

		const onWindowResize = () => {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

		}

		const animate = () => {

			// requestAnimationFrame(animate);
			// render();

			renderer.setAnimationLoop(render);

		}

		const render = () => {
			const delta = clock.getDelta();
			controls.update(delta);

			globalTime.value = clock.elapsedTime;

			/// analysers
			stemsGroup.children.forEach(obj => {
				// console.log(obj)
				if (!obj?.isHighlighted && mats.length > 0 && analysers.length > 0) {
					mats[obj.name].emissive.r = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.g = analysers[obj.name].getAverageFrequency() / 256 * 2;
					// mats[obj.name].emissive.b = analysers[obj.name].getAverageFrequency() / 256 * 2;
				}
			})

			/// lyrics
			lyrics.currentTime = performance.now();
			lyrics.timeDelta = parseInt(lyrics.currentTime - lyrics.startTime);

			if ((lyrics.timeDelta + lyrics.timeOffset) >= lyrics.lines[lyrics.lineIndex]?.startTimeMs && !lyrics.ended) {
				console.log(lyrics.lines[lyrics.lineIndex].words);

				text.text = lyrics.lines[lyrics.lineIndex].words;
				text.sync();
				lyrics.lineIndex++;
			}
			if (typeof lyrics.lines[lyrics.lineIndex] == 'undefined') { lyrics.ended = true }
			///

			/// controller code
			/// find intersections
			controllers.forEach(controller => {
				/// 'controller' is the controller object aka 'this' in the event listeners
				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				const intersects = raycaster.intersectObjects(stemsGroup.children, false);

				if (intersects.length > 0) {
					/// is the object we're pointing at the same as the previous frame?
					if (controller.userData.INTERSECTED != intersects[0].object) {
						/// if not, remove the highlight from the previous object (if it exists)
						if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }

						/// set the color of the old object back to what it was
						if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);

						/// set the current object to be the new INTERSECTED object
						controller.userData.INTERSECTED = intersects[0].object;
						/// get the current color to revert to later when deselecting
						controller.userData.INTERSECTED.currentHex = controller.userData.INTERSECTED.material.emissive.getHex();
						/// modify the color of the object (apply highlight)
						controller.userData.INTERSECTED.material.emissive.setHex(0xffbb00);
						/// finally set object state to be highlighted
						controller.userData.INTERSECTED.isHighlighted = true;
					}

					/// is this the first time we're clicking on the object? (and are we not dragging an object)
					if (controller.userData.isSelecting && !controller.userData.isHolding && !controller.userData.selected) {
						/// set for next frame
						controller.userData.isHolding = true;
						controller.userData.intent = { holdLog: [], action: 0 };

						const volume = sounds[controller.userData.INTERSECTED.name].getVolume();

						switch (volume) {
							case 0:
								sounds[controller.userData.INTERSECTED.name].setVolume(1);
								controller.userData.intent.action = 1; /// update action if unmuting
								break;
							case 1:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
							default:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
						}
					} else if (!controller.userData.isSelecting && controller.userData.isHolding) {
						controller.userData.isHolding = false;
					}

					/// checks for user intent
					if (controller.userData.isSelecting && controller.userData.isHolding && !controller.userData.selected) {

						if (controller.userData.intent?.holdLog.at(-1) != intersects[0].object) {
							if (controller.userData.intent.holdLog == undefined) {
								controller.userData.intent.holdLog = [];
							}
							controller.userData.intent.holdLog.push(intersects[0].object)
						} else {
							sounds[controller.userData.INTERSECTED.name].setVolume(controller.userData.intent.action);

						}
					}

				} else {
					/// clean up and reset currently highlighted objects to their original color/state
					if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }
					if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);
					controller.userData.INTERSECTED = undefined;
				}
			})

			renderer.render(scene, camera);
		}

		function init() {
			const overlay = document.getElementById('overlay');
			overlay.remove();
			console.log(currentStems)

			initScene()
			// unloadAudio()
			// loadTrack(playListJson.tracks[10])
			initStems(currentStems)
			initVideoGroup(vidConfig)
			initControllers()
			// initGui()
			initLyrics()
			// for (const stem in currentStems) { currentStems[stem].play() }

			initFloor()

			setTimeout(() => {
				unloadAudio()
				// loadTrack(playListJson.tracks[9])
			}, 5000);
			setTimeout(() => {
				loadTrack(playListJson.tracks[10])
				// initStems(currentStems)
			}, 7000);
			setTimeout(() => {
				// loadTrack(playListJson.tracks[10])
				initStems(currentStems)
			}, 9000);
			setTimeout(() => {
				console.log({ mats })
				console.log({ meshes })
				console.log({ sounds })
				console.log({ analysers })
				console.log(stemsGroup)
			}, 10000);


			controls = new FirstPersonControls(camera, renderer.domElement);
			controls.movementSpeed = 100;
			controls.lookSpeed = 0.30;
			controls.noFly = false;
			controls.lookVertical = true;

			console.log({ mats })
			console.log({ meshes })
			console.log({ sounds })
			console.log({ analysers })

			window.addEventListener('resize', onWindowResize);
			document.body.appendChild(VRButton.createButton(renderer));

			animate();
		}
	</script>

</body>

</html>