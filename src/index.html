<!DOCTYPE html>
<html lang="en">

<head>
	<title>The virtual soundscape - Phenomena</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<link rel="shortcut icon" href="https://p3-blog.corruptedpixl.com/assets/favicons/favicon.svg">
</head>

<body>

	<!-- keep filesize low to avoid them from being slow -->
	<!-- <audio id="atmos" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/atmos.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/atmos.wav" type="audio/wav">
	</audio>
	<audio id="bass" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/bass.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/bass.wav" type="audio/wav">
	</audio>
	<audio id="drums" preload="auto" style="display: none">
		<source src="media/audio/wdyf/drums.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/drums.wav" type="audio/wav">
	</audio>
	<audio id="guitars" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/guitars.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/guitars.wav" type="audio/wav">
	</audio>
	<audio id="lq" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/lq.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/lq.wav" type="audio/wav">
	</audio>
	<audio id="pads" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/pads.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/pads.wav" type="audio/wav">
	</audio>
	<audio id="plucks" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/plucks.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/plucks.wav" type="audio/wav">
	</audio>
	<audio id="tags" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/tags.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/tags.wav" type="audio/wav">
	</audio>
	<audio id="vocals" loop preload="auto" style="display: none">
		<source src="media/audio/wdyf/vocals.mp3" type="audio/mpeg">
		<source src="media/audio/wdyf/vocals.wav" type="audio/wav">
	</audio> -->


	<div id='audioContainer'></div>
	<div id='videoContainer'></div>
	<!-- <video id="video" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP1-drums.mp4" type="video/mp4" crossorigin="*">
	</video>
	<video id="video2" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP2-synths.mp4" type="video/mp4" crossorigin="*">
	</video>
	<video id="video3" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
		<source src="https://cdn.cpixl.com/other/PhenomenaTV/PTVEP3-guitars.mp4" type="video/mp4" crossorigin="*">
	</video> -->

	<div id="overlay">
		<h1>Welcome to Phenomena: behind the music</h1>
		<p>This WebXR experience will show you how Phenomena came to be and allow you to play with the songs.</p>
		<button id="startButton">Start the experience</button>
		<p id="loading">Loading...</p>
		<p>You can view the experience in your browser by pressing this button or in VR by pressing the "enter VR" button at the bottom once the experience is started.</p>
		<p>Special thanks to Zanski for allowing me to use the stems, artwork and videos for this project!</p>
	</div>

	<script type="module">

		import { Text } from 'https://cdn.skypack.dev/troika-three-text';

		import * as THREE from 'https://cdn.skypack.dev/three';
		import { GUI } from 'https://cdn.skypack.dev/three/examples/jsm/libs/lil-gui.module.min.js';
		import { FirstPersonControls } from 'https://cdn.skypack.dev/three/examples/jsm/controls/FirstPersonControls.js';
		import { VRButton } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/VRButton.js';
		import { XRControllerModelFactory } from 'https://cdn.skypack.dev/three/examples/jsm/webxr/XRControllerModelFactory.js';
		import { GLTFLoader } from 'https://cdn.skypack.dev/three/examples/jsm/loaders/GLTFLoader.js';

		import StarShader from './shaders/StarShader.js';
		import FloorShader from './shaders/FloorShader.js';

		// const lyrics = await fetch('lyrics/forest-spirit-sound.json').then(response => response.json());

		let camera, controls, scene, raycaster, renderer, light, listener, textureEquirec, waterTexture, noteObject, skyMaterial;
		let controller, controllerGrip;
		let playListJson, albumArt, albumTitle, artist, lyrics;
		let currentStems = [];
		let currentLyrics = [];
		let globalTime = { value: 0 };
		const tempMatrix = new THREE.Matrix4();
		const text = new Text();

		let mats = [];
		let meshes = [];
		let sounds = [];
		let videos = [];
		let analysers = [];
		let HDRIS = [];

		let controllers = [];
		let controllerGrips = [];

		// groups
		let stemsGroup = new THREE.Group();
		let vidGroup = new THREE.Group();
		let songSelectGroup = new THREE.Group();

		const clock = new THREE.Clock();
		const textureLoader = new THREE.TextureLoader();

		const startButton = document.getElementById('startButton');
		startButton.addEventListener('click', init);

		const vidConfig = ['video', 'video2', 'video3']
		const HDRIConfig = ['white', 'black', 'lines', 'sat', 'sat2', 'dark_white', 'dark_black', 'dark_dark', 'dark_light', 'light_darker', 'dark_sat', 'light_darkerer']

		const refDist = 50; // distance from where to start applying volume reduction 
		// const objConfig = [
		// 	{ name: 'atmos', color: 0xDDD3C3, sound: 'atmos', },
		// 	{ name: 'bass', color: 0x812ADE, sound: 'bass', },
		// 	{ name: 'drums', color: 0x3444E3, sound: 'drums', },
		// 	{ name: 'guitars', color: 0xC714D6, sound: 'guitars', },
		// 	{ name: 'lq', color: 0xE4406E, sound: 'lq', },
		// 	{ name: 'pads', color: 0xFFA211, sound: 'pads', },
		// 	{ name: 'plucks', color: 0xFFDE4A, sound: 'plucks', },
		// 	{ name: 'tags', color: 0x02D37A, sound: 'tags', },
		// 	{ name: 'vocals', color: 0x51C5C5, sound: 'vocals', },]


		const getPlaylist = async (url) => {
			// playListJson = await fetch(url).then(response => response.json());
			// return playListJson;
			return await fetch(url).then(response => response.json());
		}
		const initPlaylist = async () => {
			playListJson = await getPlaylist('media/json/playlist.json');
			albumArt = playListJson.albumArt;
			albumTitle = playListJson.album;
			artist = playListJson.artist;

			albumArt = preloadImgs([albumArt]); /// allows to load multiple sources if needed
			preloadVideos(playListJson.videos); /// loads all videos and appends them to the dom to access later
			preloadAudio()
		}

		const preloadImgs = async (imgs) => {
			imgs.forEach(async img => {
				const image = new Image();
				image.src = img;
				return image;
			})
		}

		const preloadVideos = (videos) => {
			// videos.map(video => {
			// 	const video = new Video();
			// 	image.src = img;
			// 	console.log(image)
			// 	document.querySelector('body').appendChild(image);
			// 	return image;
			// })

			/// TODO ADD VIDEOS TO VIDCONFIG HERE

			const $videoContainer = document.querySelector('#videoContainer');
			$videoContainer.innerHTML = videos.map(video => `
			<video id="${video.id}" preload="auto" style="display: none" crossorigin="anonymous" muted controls loop>
				<source src="${video.url}" type="video/mp4" crossorigin="*">
			</video>`
			).join(``)
		}

		const preloadAudio = () => {
			const defaultTrack = 9;
			loadTrack(playListJson.tracks[defaultTrack]);
		}

		const loadTrack = (track) => {
			return new Promise((resolve, reject) => {
				currentStems = [];
				const $audioContainer = document.querySelector('#audioContainer');
				// $audioContainer.innerHTML = track.stems.map(stem => `
				// <audio id="${stem}" loop preload="auto" style="display: none">
				// 	<source src="${track.stemsPath}${stem}.mp3" type="audio/mpeg">
				// </audio>`
				// ).join(``)
				console.log('%c%s', 'color: #9FE3FF', `Now loading: ${track.title}`);
				track.stems.forEach(stem => {
					const audio = new Audio();
					audio.src = `${track.stemsPath}${stem.name}.mp3`;
					audio.loop = true;
					audio.name = stem.name;
					$audioContainer.appendChild(audio);
					audio.oncanplaythrough = (e) => {
						const $loading = document.querySelector('#loading');
						currentStems[audio.name] = { ...stem, "audio": audio };
						console.log('%c%s', 'color: #4AF2FF', `Loaded ${audio.name}`);
						if (Object.keys(currentStems).length === track.stems.length) {
							if ($loading) $loading.innerHTML = 'Loaded all stems!'
							console.log('%c%s', 'color: #1F8BFF', `All stems loaded.`);

							resolve();

							// if (!document.getElementById('overlay')) {
							// 	console.log(currentStems);
							// 	initStems(currentStems);
							// }
						}
					};
					// return audio;
				})
			})
		}

		const unloadAudio = () => {

			return new Promise((resolve, reject) => {
				const $audioContainer = document.querySelector('#audioContainer');
				// for (const stem in currentStems) {
				// 	currentStems[stem].audio.pause();
				// }
				$audioContainer.innerHTML = '';


				// for (const mesh in meshes) {
				// }
				// console.log(meshes[mesh])
				// const object = scene.getObjectByProperty('uuid', meshes[mesh].uuid);
				const stemsGroup = scene.getObjectByProperty('name', 'stemsGroup');
				console.log(stemsGroup)
				let stemsToBeRemoved = [...stemsGroup.children]; /// make a clone of the children to loop over otherwise the array will shorten during the loop and this skip every 2nd item
				for (const stem in stemsToBeRemoved) {
					console.log(stemsToBeRemoved[stem])
					const stemObject = stemsToBeRemoved[stem];
					stemObject.geometry.dispose();
					stemObject.material.dispose();
					// stemObject.children.forEach(child => {
					// 	child?.source?.disconnect();
					// });
					delete mats[stemsToBeRemoved[stem].name]
					delete meshes[stemsToBeRemoved[stem].name]
					delete sounds[stemsToBeRemoved[stem].name]
					delete analysers[stemsToBeRemoved[stem].name]
					stemObject.removeFromParent();
				}
				stemsToBeRemoved = [];


				scene.remove(stemsGroup);
				console.log(stemsGroup)
				// mats = [];
				// meshes = [];
				// sounds = [];
				// analysers = [];
				renderer.renderLists.dispose();

				console.log({ mats })
				console.log({ meshes })
				console.log({ sounds })
				console.log({ analysers })
				resolve();
			})
		}

		initPlaylist();

		const initScene = () => {
			return new Promise((resolve, reject) => {

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, .1, 10000);
				camera.position.set(0, 20, 0);

				listener = new THREE.AudioListener();
				camera.add(listener);

				scene = new THREE.Scene();
				// scene.fog = new THREE.FogExp2(0x000000, 0.0025);

				// const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
				const light = new THREE.DirectionalLight(0xffffbb);
				light.position.set(100, 30, -100).normalize();
				light.castShadow = true;
				scene.add(light);

				const light1 = new THREE.PointLight(0xffffff, .03, 0);
				light1.position.set(0, 200, 0);
				scene.add(light1);
				const light2 = new THREE.PointLight(0xffffff, .01, 0);
				light2.position.set(100, 10, 50);
				scene.add(light2);

				/// ground
				const helper = new THREE.GridHelper(1000, 10, 0x444444, 0x444444);
				helper.position.y = 0.1;
				scene.add(helper);

				/// Raycaster
				raycaster = new THREE.Raycaster();

				///////////////////////
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				/// enable webxr
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				renderer.xr.enabled = true;
				document.body.appendChild(renderer.domElement);
				// initStems(objConfig)
				resolve();
			})
		}

		const initStems = (currentStems) => {
			const sphere = new THREE.SphereGeometry(20, 32, 16);
			// let note;
			/////////////// GLTF
			const loader = new GLTFLoader().setPath('models/');
			loader.load('note_gold.gltf', (gltf) => {
				// console.log(gltf)
				const noteModel = gltf.scene;
				// const noteModel = new THREE.Mesh(gltf.scene.children[0], new THREE.MeshLambertMaterial({ color: 0xDDD3C3, envMap: textureEquirec, reflectivity: 1 }));
				noteModel.envMap = textureEquirec;
				// noteModel.children[0].material = new THREE.MeshLambertMaterial({ color: 0xDDD3C3, envMap: textureEquirec, reflectivity: 1 });
				noteModel.children[0].material.envMap = textureEquirec;
				// noteModel.needsUpdate = true;
				// scene.add(noteModel);
				noteObject = noteModel.children[0].geometry;
				loadStems(currentStems).then(() => { initGui(); });
			});
			///////////////
		}

		const loadStems = (currentStems) => {

			return new Promise((resolve, reject) => {
				const populateArrays = new Promise((resolve, reject) => {
					for (const stem in currentStems) {
						// create a new material with the color of the object
						mats[currentStems[stem].name] = new THREE.MeshPhongMaterial({ color: currentStems[stem].color, flatShading: true, shininess: .1, specular: currentStems[stem].color });
						// create a new mesh with that material
						// meshes[obj.name] = new THREE.Mesh(sphere, mats[obj.name]) /// old mesh
						meshes[currentStems[stem].name] = new THREE.Mesh(noteObject, mats[currentStems[stem].name])
						/// TODO change color of included material in gltf so the environment is reflected. 
						meshes[currentStems[stem].name].name = currentStems[stem].name;
						meshes[currentStems[stem].name].rotateY(Math.PI);
						// scene.add(meshes[stem.name]); // DONT ADD EACH OBJECT INDIVIDUALLY
						stemsGroup.add(meshes[currentStems[stem].name]);

						// create audio sources, load from html and add to stemects
						sounds[currentStems[stem].name] = new THREE.PositionalAudio(listener);
						// const currentSound = document.querySelector(`#${currentStems[stem].name}`) /// old loading func
						const currentSound = currentStems[stem].audio;
						sounds[currentStems[stem].name].setMediaElementSource(currentSound).setRefDistance(refDist);
						// currentSound.play(); /// dont play here but after everything's loaded
						meshes[currentStems[stem].name].add(sounds[currentStems[stem].name]);
						// start analysers
						analysers[currentStems[stem].name] = new THREE.AudioAnalyser(sounds[currentStems[stem].name], 32);
					}
					console.log(meshes)
					resolve()
				})

				populateArrays.then(res => {
					console.log(meshes)
					let i = 0;
					const spacer = 50;
					// set positions of objects
					for (const mesh in meshes) {
						meshes[mesh].position.set((spacer * 2.15 - (spacer * i)), 30, 100)
						meshes[mesh].scale.set(.7, .7, .7)
						i++
					}

					// meshes['atmos'].position.set(- 250, 30, 100);
					// meshes['bass'].position.set(- 200, 30, 100);
					// meshes['drums'].position.set(- 150, 30, 100);
					// meshes['guitars'].position.set(- 100, 30, 100);
					// meshes['lq'].position.set(- 50, 30, 100);
					// meshes['pads'].position.set(0, 30, 100);
					// meshes['plucks'].position.set(50, 30, 100);
					// meshes['tags'].position.set(100, 30, 100);
					// meshes['vocals'].position.set(150, 30, 100);
				})

				stemsGroup.name = 'stemsGroup';
				scene.add(stemsGroup); // ADD STEMS GROUP TO THE SCENE

				// initGui() /// TODO GETS CALLED TWICE BECAUSE ITS NOT A PROMISE, SHOULD ONLY FIRE IN INIT
				for (const stem in currentStems) { currentStems[stem].audio.play() } /// Finally start playing them all (as close as possible) at the same time
				resolve();
			})
		}

		const initVideoGroup = (vidConfig) => {
			// VIDEOooo
			const vidTextures = [];

			vidConfig.forEach(video => {
				const currentVid = document.querySelector(`#${video}`);
				// videos[video] = currentVid;
				videos.push(currentVid);
				vidTextures.push(new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(currentVid), }));
				// console.log(currentVid)
				// console.log(videos)
			});
			// const video = document.querySelector('#video');
			// const video2 = document.querySelector('#video2');
			// const video3 = document.querySelector('#video3');



			// const vidTextures = [
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video), }), /// side: THREE.DoubleSide  can prob be omitted (NEEDS TESTING)
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2), }), ///  side: THREE.DoubleSide can prob be omitted (NEEDS TESTING)
			// 	new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3), }), ///  side: THREE.DoubleSide can prob be omitted (NEEDS TESTING)
			// ];

			// const vidTex = new THREE.VideoTexture(video);
			// // vidTex.needsUpdate;
			// vidTex.minFilter = THREE.LinearFilter;
			// vidTex.magFilter = THREE.LinearFilter;
			// vidTex.format = THREE.RGBFormat;
			// // vidTex.wrapS = THREE.CubeReflectionMapping;
			// // vidTex.wrapT = THREE.CubeReflectionMapping;
			// vidTex.repeat.set(100, 100);
			// // video.crossOrigin = 'anonymous';

			const triangleSize = .5;
			const triangle = new THREE.Shape(); // create a triangle
			triangle.moveTo(10 * triangleSize, 0); // right point
			triangle.lineTo(-9.4 * triangleSize, 0); // left point
			triangle.lineTo(0.16, 16.8 * triangleSize); // top point
			triangle.lineTo(10 * triangleSize, 0); // back to start to close the shape

			const vidShapeSideOne = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			const vidShapeSideTwo = new THREE.Mesh(
				new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: .1, }),
				new THREE.MeshBasicMaterial({ color: 0xffbb00 })
			)
			vidShapeSideOne.position.set(10, 10.08, -14.85);
			vidShapeSideTwo.position.set(-10, 10.08, -14.85);
			vidShapeSideOne.rotateY(Math.PI / 2); // 180° radians
			vidShapeSideTwo.rotateY(Math.PI / 2); // 180° radians
			// scene.add(vidShapeSideOne);
			// scene.add(vidShapeSideTwo);

			// let vidMesh = new THREE.Mesh(
			// 	// new THREE.PlaneGeometry(20, 10),
			// 	new THREE.ExtrudeGeometry(triangle, { steps: 1, depth: 30, }), // extrude triangle
			// 	// new THREE.MeshBasicMaterial({ map: vidTex }));
			// 	// extrudedTriangle,
			// 	[
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video2) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		// new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video3) }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffbb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00bb00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
			// 		new THREE.MeshBasicMaterial({ color: 0x0000ff }),
			// 		new THREE.MeshBasicMaterial({ color: 0xffffff }),
			// 	]);
			// // new THREE.MeshFaceMaterial(vidTextures));
			// // new THREE.MeshBasicMaterial({ color: 0xffbb00 }));

			// vidMesh.position.set(0, 0, -4);
			// vidMesh.userData.isDraggable = true;
			// vidMesh.name = 'e-triangle'
			// vidMesh.scale.set(.05, .05, .05);
			// scene.add(vidMesh)

			/// Video mesh group
			let vidSideAlpha = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[0]);
			vidSideAlpha.name = 'vidSideAlpha';
			vidSideAlpha.position.set(0, 14.33, -17.5);
			vidSideAlpha.rotateY(Math.PI); // 180° radians
			vidSideAlpha.rotateZ(Math.PI); // 180° radians
			vidSideAlpha.rotateX(0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidSideAlpha.material.side = THREE.DoubleSide; // render both sides
			let vidSideBeta = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[1]);
			vidSideBeta.name = 'vidSideBeta';
			vidSideBeta.position.set(0, 10, -15);
			vidSideBeta.rotateX(1.5708); // 90° in radians
			let vidSideGamma = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 10),
				vidTextures[2]);
			vidSideGamma.name = 'vidSideGamma';
			vidSideGamma.position.set(0, 14.33, -12.5);
			vidSideGamma.rotateX(-0.523599); // 30° in radians (formula deg to rad: angle * π / 180)
			vidGroup.add(vidSideAlpha);
			vidGroup.add(vidSideBeta);
			vidGroup.add(vidSideGamma);
			vidGroup.add(vidShapeSideOne);
			vidGroup.add(vidShapeSideTwo);
			vidGroup.userData.isDraggable = true;
			vidGroup.name = 'vidGroup';
			vidGroup.scale.set(.1, .1, .1);

			vidGroup.position.set(1.2774114085134398, 0.6355997895828723, -0.4851377603984951)
			vidGroup.rotation.set(-0.46588650970294515, -1.1860233074386377, -0.44803679405802344)

			scene.add(vidGroup);

			videos.forEach(video => {
				video.load();
				video.play();
			});

			// video.load();
			// video.play();
			// video2.load();
			// video2.play();
			// video3.load();
			// video3.play();

		}

		const initGui = () => {
			const SoundControls = function () {
				this.master = listener.getMasterVolume();
				console.log(currentStems)
				// objConfig.forEach(obj => {
				for (const stem in currentStems) {
					this[currentStems[stem].name] = sounds[currentStems[stem].name].getVolume();
				}
			};


			const gui = new GUI();
			const soundControls = new SoundControls();
			// const generatorControls = new GeneratorControls();
			const volumeFolder = gui.addFolder('sound volume');
			// const generatorFolder = gui.addFolder('sound generator');

			volumeFolder.add(soundControls, 'master').min(0.0).max(1.0).step(0.01).onChange(function () {
				listener.setMasterVolume(soundControls.master);
				////// TEMP REMOVE
				if (soundControls.master < .3) { scene.background = HDRIS.light_darkerer; }
				if (soundControls.master > .3 && soundControls.master < .6) { scene.background = HDRIS.dark_light; }
				if (soundControls.master > .6 && soundControls.master < .8) { scene.background = HDRIS.sat2; }
				if (soundControls.master > .8) { scene.background = HDRIS.dark_sat; }
			});

			// add controls for each sound loaded
			// objConfig.forEach(obj => {
			for (const stem in currentStems) {
				volumeFolder.add(soundControls, currentStems[stem].name, 0, 1, 0.01).onChange(value => {
					sounds[currentStems[stem].name].setVolume(value);
				});
			}
			volumeFolder.open();
		}

		const initControllers = () => {
			/// webxr stuff
			function onSelectStart(e) {
				this.userData.isSelecting = true;


				const controller = e.target;

				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				///! could be optimized slightly by adding all draggable objects to a group and only checking intersections on that group instead of the whole scene
				const intersects = raycaster.intersectObjects(scene.children, false);
				const intersectsVidGroup = raycaster.intersectObjects(vidGroup.children, false);
				const intersectsSongSelect = raycaster.intersectObjects(songSelectGroup.children, false);
				// console.log({ intersectsVidGroup })

				/// standalone objects
				if (intersects.length > 0) {
					intersects.forEach(obj => {
						if (!obj.object.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

				}

				/// video group obj
				if (intersectsVidGroup.length > 0) {

					if (this.userData?.videoGroup?.lastVideoObj === intersectsVidGroup[0].object && performance.now() - this.userData?.videoGroup?.lastClick <= 400) {
						// console.log(parseInt(performance.now()))
						// console.log(this.userData.videoGroup)
						switch (intersectsVidGroup[0].object.name) {
							case 'vidSideAlpha':
								videos[0].muted = !videos[0].muted;
								break;
							case 'vidSideBeta':
								videos[1].muted = !videos[1].muted;
								break;
							case 'vidSideGamma':
								videos[2].muted = !videos[2].muted;
								break;

							default:
								break;
						}
					}

					intersectsVidGroup.forEach(obj => {
						if (!obj.object.parent.userData?.isDraggable) { return }
						else if (obj.object.parent.userData?.isDraggable) {
							const object = obj.object.parent;
							controller.attach(object);

							controller.userData.selected = object;
						}
						else {
							console.log('Dragging', { obj })
							const object = obj.object;
							controller.attach(object);
							controller.userData.selected = object;
						}
					})

					this.userData.videoGroup = {
						lastVideoObj: intersectsVidGroup[0].object,
						lastClick: performance.now()
					}
				}


				/// Stem selector
				if (intersectsSongSelect.length > 0) {
					if (!playListJson.tracks.some(track => track.title === intersectsSongSelect[0].object.name)) { return }
					else {
						const selectedTrack = playListJson.tracks.findIndex(track => track.title === intersectsSongSelect[0].object.name);
						console.log('selected track', selectedTrack)
						unloadAudio()
							.then(() => loadTrack(playListJson.tracks[selectedTrack]))
							.then(() => loadStems(currentStems))
							.then(() => loadLyrics(playListJson.tracks[selectedTrack]))
					}
				}

			}

			function onSelectEnd(e) {
				/// 'this' is the controller group
				this.userData.isSelecting = false;

				const controller = e.target;

				if (controller.userData.selected !== undefined) {

					const object = controller.userData.selected;
					scene.attach(object);

					controller.userData.selected = undefined;

				}
			}

			/// init & render controller models
			/// populate the groups
			controllers = [renderer.xr.getController(0), renderer.xr.getController(1)]
			controllerGrips = [renderer.xr.getControllerGrip(0), renderer.xr.getControllerGrip(1)]
			const controllerModelFactory = new XRControllerModelFactory();
			// controller = renderer.xr.getController(0);

			/// adding event listeners
			controllers.forEach(controller => {
				controller.addEventListener('selectstart', onSelectStart);
				controller.addEventListener('selectend', onSelectEnd);
				controller.addEventListener('connected', function (event) {
					this.add(buildController(event.data));
				});
				controller.addEventListener('disconnected', function () {
					this.remove(this.children[0]);
				});
				scene.add(controller);
			})

			/// adding models so they're visible
			controllerGrips.forEach(controllerGrip => {
				controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
				scene.add(controllerGrip);
			});

			// controller.addEventListener('selectstart', onSelectStart);
			// controller.addEventListener('selectend', onSelectEnd);
			// controller.addEventListener('connected', function (event) {
			// 	this.add(buildController(event.data));
			// });
			// controller.addEventListener('disconnected', function () {
			// 	this.remove(this.children[0]);
			// });
			// scene.add(controller);


			// controllerGrip = renderer.xr.getControllerGrip(0);
			// controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
			// scene.add(controllerGrip);
		}

		const loadLyrics = (track) => {
			lyrics = track.lyrics;

			lyrics.startTime = performance.now();
			lyrics.lineIndex = 0;
			lyrics.ended = false;
			lyrics.timeOffset = 0;

			console.log(lyrics)
		}

		const initLyrics = (track) => {
			loadLyrics(track)

			scene.add(text)

			// Set properties to configure:
			text.text = 'Loading lyrics'
			text.fontSize = 3
			text.font = 'https://cdn.cpixl.com/fonts/next/OTF/Next%20Book/NextBook-Medium.otf'
			text.position.set(-40, 10, -15)
			text.rotateY(Math.PI / 2.5)
			text.color = 0xffbb00
			text.anchorX = 'center';

			// Update the rendering:
			text.sync()
		}

		const initSongSelect = (playlist) => {
			console.log('%c%s', 'color: #D20FC7', 'Loading song select');

			/// Tracks text
			const tracks = playlist.tracks;
			for (const track in tracks) {
				const trackText = new Text();
				trackText.text = tracks[track].title;
				trackText.name = tracks[track].title
				trackText.fontSize = 2
				trackText.font = 'https://cdn.cpixl.com/fonts/next/OTF/Next%20Book/NextBook-Medium.otf'
				trackText.position.set(0, - track * 2.5, 0)
				// trackText.rotateY(Math.PI)
				trackText.color = 0xffffff
				// trackText.anchorX = 'center';

				// Update the rendering:
				trackText.sync()
				songSelectGroup.add(trackText)
			}

			const albumText = new Text();
			albumText.text = playListJson.album;
			albumText.name = playListJson.album;
			albumText.fontSize = 3;
			albumText.font = 'https://cdn.cpixl.com/fonts/next/OTF/Next%20Book/NextBook-Bold.otf';
			albumText.position.set(-22, -21, 0);
			songSelectGroup.add(albumText);

			const artistText = new Text();
			artistText.text = playListJson.artist;
			artistText.name = playListJson.artist;
			artistText.fontSize = 2;
			artistText.font = 'https://cdn.cpixl.com/fonts/next/OTF/Next%20Book/NextBook-Regular.otf';
			artistText.position.set(-22, -24, 0);
			songSelectGroup.add(artistText);


			/// Album art
			let albumArtTexture = textureLoader.load(playListJson.albumArt);
			albumArtTexture.encoding = THREE.sRGBEncoding;

			const albumArtPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(20, 20),
				new THREE.MeshBasicMaterial({ map: albumArtTexture, side: THREE.DoubleSide })
			);
			albumArtPlane.position.set(-12, -10, 0);
			songSelectGroup.add(albumArtPlane)
			// albumArtPlane.position.set(1, 1, 1)


			songSelectGroup.name = 'songSelectGroup';
			songSelectGroup.position.set(0, 40, -50);
			scene.add(songSelectGroup);
			console.log(songSelectGroup)
		}

		const initFloor = () => {
			/////////////// shader
			// const shader = FloorShader.fragment;

			const material = new THREE.ShaderMaterial({
				uniforms: {

					time: globalTime,
					resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }

				},
				vertexShader: FloorShader.vertex,
				fragmentShader: FloorShader.fragment
			});

			const testPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(10000, 10000),
				material
			);

			scene.add(testPlane);
			testPlane.rotateX(- Math.PI / 2)
			testPlane.position.set(0, -150, 0)
			////////////////

			////////////////////////////
			var skyDomeRadius = 5000.01;
			skyMaterial = new THREE.ShaderMaterial({
				uniforms: {
					time: { value: 0 },
					skyRadius: { value: skyDomeRadius },
					env_c1: { value: new THREE.Color('#000000') }, /// set to black for blending later
					env_c2: { value: new THREE.Color('#000000') }, /// set to black for blending later
					noiseOffset: { value: new THREE.Vector3(100.01, 100.01, 100.01) },
					starSize: { value: 0.004 },
					starDensity: { value: 0.09 },
					clusterStrength: { value: 0.1 },
					clusterSize: { value: 0.2 },
				},
				vertexShader: StarShader.vertex,
				fragmentShader: StarShader.fragment,
				side: THREE.DoubleSide,
				transparent: true,
				blending: THREE.AdditiveBlending,
			});
			var sphereGeometry = new THREE.SphereGeometry(skyDomeRadius, 20, 20);
			var skyDome = new THREE.Mesh(sphereGeometry, skyMaterial);
			scene.add(skyDome);
			////////////////////////////


			/////////////// HDRI
			// const textureLoader = new THREE.TextureLoader();
			HDRIConfig.forEach(HDRI => {
				const currentHDRI = textureLoader.load(`textures/hdri-${HDRI}.png`);
				currentHDRI.mapping = THREE.EquirectangularReflectionMapping;
				currentHDRI.encoding = THREE.sRGBEncoding;

				HDRIS[HDRI] = currentHDRI;
			})

			//// remove skydome hdri
			// var sphereGeometry = new THREE.SphereGeometry(5000, 20, 20);
			// var skyMaterial = new THREE.MeshBasicMaterial({ envMap: HDRIS.dark_dark, side: THREE.BackSide });
			// var skyDome = new THREE.Mesh(sphereGeometry, skyMaterial);
			// scene.add(skyDome);

			/////////// WATER TEXTURE
			waterTexture = textureLoader.load(`textures/waternormals.jpg`);
			waterTexture.magFilter = THREE.NearestFilter;
			waterTexture.wrapT = THREE.RepeatWrapping;
			waterTexture.wrapS = THREE.RepeatWrapping;
			waterTexture.repeat.set(800, 2000.5);

			// const textureLoader = new THREE.TextureLoader();
			// textureEquirec = textureLoader.load('textures/hdri-skygone.png');
			// textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
			// textureEquirec.encoding = THREE.sRGBEncoding;
			scene.background = HDRIS.dark_light;
			///////////////

			//////////////// Glass plane
			const glassPlane = new THREE.Mesh(
				new THREE.PlaneGeometry(2000, 2000),
				new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 1,
					ior: 1.1,
					alpha: .5,
					alphaMap: waterTexture,
					envMap: HDRIS.dark_white,
					envMapIntensity: 1,
					transmission: 1,
					specularIntensity: 1,
					specularColor: 0xffffff,
					opacity: 1,
					thickness: 2,
					side: THREE.DoubleSide,
					transparent: true,
					clearcoat: 1,
					clearcoatMap: waterTexture,

				}))

			glassPlane.rotateX(- Math.PI / 2)
			// glassPlane.receiveShadow
			scene.add(glassPlane);
			///////////////
		}

		const buildController = (data) => {

			let geometry, material;

			switch (data.targetRayMode) {

				case 'tracked-pointer':

					geometry = new THREE.BufferGeometry();
					geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
					geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

					material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

					return new THREE.Line(geometry, material);

				case 'gaze':

					geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
					material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
					return new THREE.Mesh(geometry, material);

			}

		}

		const onWindowResize = () => {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

		}

		const animate = () => {

			// requestAnimationFrame(animate);
			// render();

			renderer.setAnimationLoop(render);

		}

		const render = () => {
			const delta = clock.getDelta();
			controls.update(delta);

			globalTime.value = clock.elapsedTime;
			skyMaterial.uniforms.time.value = clock.getElapsedTime();

			/// analysers
			for (const obj in stemsGroup.children) {
				if (!stemsGroup.children[obj]?.isHighlighted) {
					mats[stemsGroup.children[obj].name].emissive.r = analysers[stemsGroup.children[obj].name].getAverageFrequency() / 256 * 2;

					// mats[stemsGroup.children[obj].name].emissive.g = analysers[stemsGroup.children[obj].name].getAverageFrequency() / 256;
					// mats[stemsGroup.children[obj].name].emissive.b = analysers[stemsGroup.children[obj].name].getAverageFrequency() / 256;

					/// change hdri based on volume
					if (stemsGroup.children[obj].name === 'drums') {
						// console.log(analysers[stemsGroup.children[obj].name].getAverageFrequency())
						// console.log(analysers[stemsGroup.children[obj].name].getFrequencyData())
						const data = analysers[stemsGroup.children[obj].name].getFrequencyData()

						// if (Math.min(Math.max(analysers[stemsGroup.children[obj].name].getAverageFrequency(), 0), 100) / 100 >= .95) {
						if ((data[0] / 255 + data[1] / 255 + data[2] / 255) / 3 >= .85) {
							scene.background = HDRIS.light_darkerer
						} else if (scene.background !== HDRIS.dark_light) {
							scene.background = HDRIS.dark_light
						}

					}
				}
			}

			/// lyrics
			lyrics.currentTime = performance.now();
			lyrics.timeDelta = parseInt(lyrics.currentTime - lyrics.startTime);

			if ((lyrics.timeDelta + lyrics.timeOffset) >= lyrics.lines[lyrics.lineIndex]?.startTimeMs && !lyrics.ended) {
				console.log(lyrics.lines[lyrics.lineIndex].words);

				text.text = lyrics.lines[lyrics.lineIndex].words;
				text.sync();
				lyrics.lineIndex++;
			}
			if (typeof lyrics.lines[lyrics.lineIndex] == 'undefined') { lyrics.ended = true }
			///

			/// controller code
			/// find intersections
			controllers.forEach(controller => {
				/// 'controller' is the controller object aka 'this' in the event listeners
				tempMatrix.identity().extractRotation(controller.matrixWorld);

				raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
				raycaster.ray.direction.set(0, 0, - 1).applyMatrix4(tempMatrix);

				const intersects = raycaster.intersectObjects(stemsGroup.children, false);

				if (intersects.length > 0) {
					/// is the object we're pointing at the same as the previous frame?
					if (controller.userData.INTERSECTED != intersects[0].object) {
						/// if not, remove the highlight from the previous object (if it exists)
						if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }

						/// set the color of the old object back to what it was
						if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);

						/// set the current object to be the new INTERSECTED object
						controller.userData.INTERSECTED = intersects[0].object;
						/// get the current color to revert to later when deselecting
						controller.userData.INTERSECTED.currentHex = controller.userData.INTERSECTED.material.emissive.getHex();
						/// modify the color of the object (apply highlight)
						controller.userData.INTERSECTED.material.emissive.setHex(0xffbb00);
						/// finally set object state to be highlighted
						controller.userData.INTERSECTED.isHighlighted = true;
					}

					/// is this the first time we're clicking on the object? (and are we not dragging an object)
					if (controller.userData.isSelecting && !controller.userData.isHolding && !controller.userData.selected) {
						/// set for next frame
						controller.userData.isHolding = true;
						controller.userData.intent = { holdLog: [], action: 0 };

						const volume = sounds[controller.userData.INTERSECTED.name].getVolume();

						switch (volume) {
							case 0:
								sounds[controller.userData.INTERSECTED.name].setVolume(1);
								controller.userData.intent.action = 1; /// update action if unmuting
								break;
							case 1:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
							default:
								sounds[controller.userData.INTERSECTED.name].setVolume(0);
								break;
						}
					} else if (!controller.userData.isSelecting && controller.userData.isHolding) {
						controller.userData.isHolding = false;
					}

					/// checks for user intent
					if (controller.userData.isSelecting && controller.userData.isHolding && !controller.userData.selected) {

						if (controller.userData.intent?.holdLog.at(-1) != intersects[0].object) {
							if (controller.userData.intent.holdLog == undefined) {
								controller.userData.intent.holdLog = [];
							}
							controller.userData.intent.holdLog.push(intersects[0].object)
						} else {
							sounds[controller.userData.INTERSECTED.name].setVolume(controller.userData.intent.action);

						}
					}

				} else {
					/// clean up and reset currently highlighted objects to their original color/state
					if (controller.userData.INTERSECTED != undefined) { controller.userData.INTERSECTED.isHighlighted = false; }
					if (controller.userData.INTERSECTED) controller.userData.INTERSECTED.material.emissive.setHex(controller.userData.INTERSECTED.currentHex);
					controller.userData.INTERSECTED = undefined;
				}
			})

			renderer.render(scene, camera);
		}

		function init() {
			const overlay = document.getElementById('overlay');
			overlay.remove();
			console.log(currentStems)

			initScene()
				.then(() => initStems(currentStems))
				.then(() => initVideoGroup(vidConfig))
				.then(() => initControllers())
				.then(() => initLyrics(playListJson.tracks[9]))
				.then(() => initFloor())
				.then(() => initSongSelect(playListJson))


			// // unloadAudio()
			// // loadTrack(playListJson.tracks[10])
			// initStems(currentStems)
			// initVideoGroup(vidConfig)
			// initControllers()
			// // initGui()
			// initLyrics(playListJson.tracks[9])
			// // for (const stem in currentStems) { currentStems[stem].play() }
			// initFloor()

			// setTimeout(() => {
			// 	unloadAudio()
			// 		.then(() => loadTrack(playListJson.tracks[10]))
			// 		.then(() => loadStems(currentStems))
			// 		.then(() => loadLyrics(playListJson.tracks[10]))
			// }, 5000);

			// setTimeout(() => {
			// 	console.log({ mats })
			// 	console.log({ meshes })
			// 	console.log({ sounds })
			// 	console.log({ analysers })
			// 	console.log(stemsGroup)
			// }, 8000);

			// setTimeout(() => {
			// 	unloadAudio()
			// 		.then(() => loadTrack(playListJson.tracks[9]))
			// 		.then(() => loadStems(currentStems))
			// 		.then(() => loadLyrics(playListJson.tracks[9]))
			// }, 20000);


			controls = new FirstPersonControls(camera, renderer.domElement);
			controls.movementSpeed = 100;
			controls.lookSpeed = 0.30;
			controls.noFly = false;
			controls.lookVertical = true;

			console.log({ mats })
			console.log({ meshes })
			console.log({ sounds })
			console.log({ analysers })

			window.addEventListener('resize', onWindowResize);
			document.body.appendChild(VRButton.createButton(renderer));

			animate();
		}
	</script>

</body>

</html>